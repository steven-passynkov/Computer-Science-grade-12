/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package ovs;

import javax.swing.JDialog;
import javax.swing.JOptionPane;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.Callable;
import java.util.HashMap;
import java.util.Map;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.CategoryPlot;
import org.jfree.chart.renderer.category.BarRenderer;
import org.jfree.data.category.DefaultCategoryDataset;
import java.awt.Color;
import java.util.Random;
import java.util.ArrayList;
import java.util.List;

/**
 * File Name: SortingRoutines.java
 * Person Programmer: Steven Passynkov 
 * Date: 4 Oct 2024 
 * Description: The program execute sorting algorithms on randomly generated 
 * numbers and display executing time statistic
 */
public class SortingRoutines extends javax.swing.JFrame {

    // Map sorting algorighm to average time
    private Map<String, Long> sortingTimes = new HashMap<>();

    /**
     * Creates new form SortingRoutines
     */
    public SortingRoutines() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        outputTextArea = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        inputTextArea = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        insertionSortBtn = new javax.swing.JRadioButton();
        quickSortBtn = new javax.swing.JRadioButton();
        allSortBtn = new javax.swing.JRadioButton();
        bubbleSortBtn = new javax.swing.JRadioButton();
        selectionSortBtn = new javax.swing.JRadioButton();
        acdOrDecDropdown = new javax.swing.JComboBox<>();
        sortBtn = new javax.swing.JButton();
        analyticBtn = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        resetBtn = new javax.swing.JButton();
        randomBtn = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane1.setBorder(null);

        outputTextArea.setEditable(false);
        outputTextArea.setColumns(20);
        outputTextArea.setRows(5);
        outputTextArea.setEnabled(false);
        jScrollPane1.setViewportView(outputTextArea);

        inputTextArea.setColumns(20);
        inputTextArea.setRows(5);
        jScrollPane2.setViewportView(inputTextArea);

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 1, 18)); // NOI18N
        jLabel1.setText("Sorting Routines");

        insertionSortBtn.setText("Insertion");
        insertionSortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                insertionSortBtnActionPerformed(evt);
            }
        });

        quickSortBtn.setText("Quick");
        quickSortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                quickSortBtnActionPerformed(evt);
            }
        });

        allSortBtn.setText("All");
        allSortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                allSortBtnActionPerformed(evt);
            }
        });

        bubbleSortBtn.setText("Bubble");
        bubbleSortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bubbleSortBtnActionPerformed(evt);
            }
        });

        selectionSortBtn.setText("Selection");
        selectionSortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                selectionSortBtnActionPerformed(evt);
            }
        });

        acdOrDecDropdown.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Select", "Ascending", "Descending" }));

        sortBtn.setBackground(new java.awt.Color(153, 153, 255));
        sortBtn.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        sortBtn.setText("RUN SORT");
        sortBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sortBtnActionPerformed(evt);
            }
        });

        analyticBtn.setText("Analytics");
        analyticBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                analyticBtnActionPerformed(evt);
            }
        });

        jLabel2.setText("Sorting Algorithm");

        jLabel3.setText("Input");

        jLabel4.setText("Output");

        resetBtn.setText("Reset");
        resetBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetBtnActionPerformed(evt);
            }
        });

        randomBtn.setText("Regenerate List");
        randomBtn.setToolTipText("");
        randomBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                randomBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 120, Short.MAX_VALUE)
                                    .addComponent(jLabel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(selectionSortBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(bubbleSortBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(insertionSortBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(quickSortBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(allSortBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(acdOrDecDropdown, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addGap(27, 27, 27))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(jLabel1)
                                    .addComponent(jLabel2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(randomBtn)
                        .addGap(62, 62, 62)
                        .addComponent(sortBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(analyticBtn)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 59, Short.MAX_VALUE)
                            .addComponent(resetBtn)))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 115, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 34, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(randomBtn, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(sortBtn, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(analyticBtn)))
                        .addGap(18, 18, 18))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(resetBtn)
                        .addGap(18, 18, 18)))
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel2)
                        .addComponent(jLabel4))
                    .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.TRAILING))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(selectionSortBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(bubbleSortBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(insertionSortBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(quickSortBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(allSortBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(acdOrDecDropdown, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane1))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Perform selection sort
     *
     * @param nums array
     * @param ascending is ascending?
     */
    public void selectionSort(int[] nums, boolean ascending) {
        // the first for loop will grab the first number in the array
        for (int i = 0; i < nums.length - 1; i++) {
            // the 2nd loop will grab the next number in the loop so we can compare two numbers
            for (int j = i + 1; j < nums.length; j++) {
                // we are comparing two side by side array sets. The first time this runs, it will be comparing array index 0 to 1. if true swap them
                if ((ascending && nums[i] > nums[j]) || (!ascending && nums[i] < nums[j])) {
                    //create a temp variable called iVal so we can temporary hold the num[i] array to make a swap later
                    int iVal = nums[i];
                    //sets i to j's value 
                    nums[i] = nums[j];
                    // sets j to the i's value which was temporary help in iVal
                    nums[j] = iVal;
                }
            }
        }
    }

    /**
     * Perform bubble sort
     *
     * @param arr array
     * @param ascending is ascending?
     */
    public static void bubbleSort(int[] arr, boolean ascending) {
        //determine the size of the array used by getting the length
        int size = arr.length;
        //outer loop will start at 1 and run through the entire array and increment by 1 each time
        for (int pass = 1; pass < size; pass++) {
            //inner loop starts at zero and runs as long as i is less than size minus pass and increments by 1 each time
            for (int i = 0; i < size - pass; i++) {
                // do a comparasion and potential swap
                if ((ascending && arr[i] > arr[i + 1]) || (!ascending && arr[i] < arr[i + 1])) {
                    //the swap starts here
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    //ends the swap, by changing the array in i with the i+1 array
                    arr[i + 1] = temp;
                }
            }
        }
    }

    /**
     * Perform insertion sort
     *
     * @param data array
     * @param ascending is ascending?
     */
    public static void insertionSort(int[] data, boolean ascending) {
        //determine the size of the array used by getting the length
        int size = data.length;
        //begin the sorting algorithm; start an outer loop to scan the first item of the array to the end of the array
        for (int i = 0; i < size; ++i) {
            //inner loop that starts j at the same value of i (as long as it's greatern than zero) and takes away 1 from it. 
            for (int j = i; j > 0; --j) {
                //now it compairs j-1 with j , so really two items next to each other. if j-1 is greater than j, then swap them 
                if ((ascending && data[j - 1] > data[j]) || (!ascending && data[j - 1] < data[j])) {
                    //creates a temp data to hold the data in j, so we can swap it
                    int temp = data[j];
                    //swaps the data 
                    data[j] = data[j - 1];
                    //now sets j-1 to the temp value in memory. So overall j and j-1 have changed places
                    data[j - 1] = temp;
                }
            }
        }
    }

    /**
     * Perform quick sort
     *
     * @param arr the array we want sorted
     * @param left left value
     * @param right right value,
     * @param ascending is ascending?
     */
    public static void quickSort(int[] arr, int left, int right, boolean ascending) {
        //lowest part of array
        int i = left;
        //highest part of array
        int j = right;
        //this is going to be used for swapping
        int temp;
        //we select a pivot by taking the most left and most right value and finds the midpoint array value
        int pivot = arr[(left + right) / 2];

        //start the sorting process
        while (i <= j) {
            //if the data is less than the pivot, then keep moving forward
            while ((ascending && arr[i] < pivot) || (!ascending && arr[i] > pivot)) {
                //move forward
                i++;
            }
            //if the data on the right side is greater than the pivot, we move down and don't do any changes
            while ((ascending && arr[j] > pivot) || (!ascending && arr[j] < pivot)) {
                j--;
            }
            //otherwise we swap the datas
            if (i <= j) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
                //move index to next position on both sides
                i++;
                j--;
            }
        }

        // call quickSort method recursively
        if (left < j) {
            quickSort(arr, left, j, ascending);
        }
        if (i < right) {
            quickSort(arr, i, right, ascending);
        }
    }

    /**
     * Select/Deselect 'All Sort' button
     */
    private void handleSortButtonSelection() {
        // if all algorithms are selected -> All is true
        if (selectionSortBtn.isSelected() && bubbleSortBtn.isSelected() && insertionSortBtn.isSelected() && quickSortBtn.isSelected()) {
            // set to true
            allSortBtn.setSelected(true);
        } else {
            // otherwise set to false
            allSortBtn.setSelected(false);
        }
    }

    /**
     * Combine all numbers to one string with "\n" separator
     *
     * @param array array to combine
     * @return all numbers to one string with "\n" separator
     */
    private String formatSortedNumbers(int[] array) {
        // create StringBuilder
        StringBuilder sb = new StringBuilder();
        // iterate over numbers
        for (int i = 0; i < array.length; i++) {
            // add number
            sb.append(array[i]);
            // if not end of array
            if (i < array.length - 1) {
                // add "\n" as separator
                sb.append(",\n");
            }
        }
        // return StringBuilder converted to string
        return sb.toString();
    }

    /**
     * Run sort and do measurement
     *
     * @param numbers array
     * @param sortName sort name
     * @param ascending ascending?
     * @param sortFunc impl of SortFunction
     */
    private void measureSortingTime(int[] numbers, String sortName, boolean ascending, SortFunction sortFunc) {
        // time to execute
        long totalDuration = 0;
        // number of cycles to run
        int repetitions = 1000;

        // warm up and do not measure
        for (int r = 0; r < 10; r++) {
            // clone
            int[] sortedNumbers = numbers.clone();
            // run sort
            sortFunc.sort(sortedNumbers, ascending);
        }

        // do real measurament in cycle to repetitions
        for (int r = 0; r < repetitions; r++) {
            // clone
            int[] sortedNumbers = numbers.clone();
            // startTime
            long startTime = System.nanoTime();
            // run sort
            sortFunc.sort(sortedNumbers, ascending);
            // stopTime
            long endTime = System.nanoTime();
            // calculate duration
            long duration = endTime - startTime;
            // sum duration
            totalDuration += duration;
        }

        // finally sort for output
        sortFunc.sort(numbers, ascending);

        // calculate average 
        long averageDuration = totalDuration / repetitions;
        // save average time
        sortingTimes.put(sortName, averageDuration);
    }

    /**
     * Define custom FunctionalInterface to pass sorting functions
     */
    @FunctionalInterface
    private interface SortFunction {

        /**
         * each sorting function accept array to sort and boolean flag
         *
         * @param numbers array
         * @param ascending flag
         */
        void sort(int[] numbers, boolean ascending);
    }

    private void sortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sortBtnActionPerformed
        // get sort order
        String sortOrder = (String) acdOrDecDropdown.getSelectedItem();
        // if error happen
        Boolean error = false;

        // get input and split by "\n"
        String[] inputLines = inputTextArea.getText().split("\\n");
        // init array with # of lines
        int[] numbers = new int[inputLines.length];

        // iterate over lines
        for (int i = 0; i < inputLines.length; i++) {
            // get line and trim
            String line = inputLines[i].trim();

            // try to process
            try {
                // if empty
                if (line.isEmpty()) {
                    // throw error
                    throw new NumberFormatException("Input is empty");
                }

                // parse line to number
                int number = Integer.parseInt(line);
                // add number to array
                numbers[i] = number;
            } catch (NumberFormatException ex) {
                // if error
                if (!error) {
                    // show message
                    JOptionPane.showMessageDialog(this, "Please correct number", "Invalid", JOptionPane.ERROR_MESSAGE);
                }
                // set error
                error = true;
                return;
            }
        }

        // if no error
        if (!error) {
            // if no method is selected
            if (!selectionSortBtn.isSelected() && !bubbleSortBtn.isSelected() && !insertionSortBtn.isSelected() && !quickSortBtn.isSelected()) {
                // show message
                JOptionPane.showMessageDialog(this, "Please select at least one sorting option.", "No Sorting Option Selected", JOptionPane.ERROR_MESSAGE);
                // mark as error
                error = true;
                return;
            }
        }

        // if no error
        if (!error) {
            // if no order is selected
            if (!"Ascending".equals(sortOrder) && !"Descending".equals(sortOrder)) {
                // show message
                JOptionPane.showMessageDialog(this, "Please select either 'Ascending' or 'Descending' from the dropdown.", "Invalid Sorting Order", JOptionPane.ERROR_MESSAGE);
                // mark as error
                error = true;
                return;
            }
        }

        // is ascending?
        boolean ascending = "Ascending".equals(sortOrder);

        // create thread pool of 4 threads
        ExecutorService executor = Executors.newFixedThreadPool(4);
        // Populate map "Sorting name" -> Task to execute
        Map<String, Callable<Void>> sortingTasks = new HashMap<>();

        // if selection sort radio selected
        if (selectionSortBtn.isSelected()) {
            // add sortingTasks element
            sortingTasks.put("Selection Sort", () -> {
                // clone original array to make it modifable
                int[] sortedNumbers = numbers.clone();
                // call function that measure execution
                measureSortingTime(sortedNumbers, "Selection Sort", ascending, (nums, asc) -> selectionSort(nums, asc));
                // set out of sort to Output
                outputTextArea.append("Selection Result:\n" + formatSortedNumbers(sortedNumbers) + "\n");
                return null;
            });
        }
        // if bubble sort radio selected
        if (bubbleSortBtn.isSelected()) {
            // add sortingTasks element
            sortingTasks.put("Bubble Sort", () -> {
                // clone original array to make it modifable
                int[] sortedNumbers = numbers.clone();
                // call function that measure execution
                measureSortingTime(sortedNumbers, "Bubble Sort", ascending, (nums, asc) -> bubbleSort(nums, asc));
                // set out of sort to Output
                outputTextArea.append("Bubble Result:\n" + formatSortedNumbers(sortedNumbers) + "\n");
                return null;
            });
        }
        // if insertion sort radio selected
        if (insertionSortBtn.isSelected()) {
            // add sortingTasks element
            sortingTasks.put("Insertion Sort", () -> {
                // clone original array to make it modifable
                int[] sortedNumbers = numbers.clone();
                // call function that measure execution
                measureSortingTime(sortedNumbers, "Insertion Sort", ascending, (nums, asc) -> insertionSort(nums, asc));
                // set out of sort to Output
                outputTextArea.append("Insertion Result:\n" + formatSortedNumbers(sortedNumbers) + "\n");
                return null;
            });
        }
        // if quick sort radio selected
        if (quickSortBtn.isSelected()) {
            // add sortingTasks element
            sortingTasks.put("Quick Sort", () -> {
                // clone original array to make it modifable
                int[] sortedNumbers = numbers.clone();
                // call function that measure execution
                measureSortingTime(sortedNumbers, "Quick Sort", ascending, (nums, isAscending) -> quickSort(nums, 0, nums.length - 1, isAscending));
                // set out of sort to Output
                outputTextArea.append("Quick Result:\n" + formatSortedNumbers(sortedNumbers) + "\n");
                return null;
            });
        }

        try {
            // iterate over sortingTasks
            for (Map.Entry<String, Callable<Void>> entry : sortingTasks.entrySet()) {
                // Submit task to thread pool
                Future<Void> future = executor.submit(entry.getValue());
                // wait till execution finished
                future.get();
            }
        } catch (Exception e) {
            //handle exception
            e.printStackTrace();
        } finally {
            // close the pool
            executor.shutdown();
        }
    }//GEN-LAST:event_sortBtnActionPerformed

    private void allSortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_allSortBtnActionPerformed
        // select selection sorting when 'All' is clicked
        selectionSortBtn.setSelected(allSortBtn.isSelected());
        // select bubble sorting when 'All' is clicked
        bubbleSortBtn.setSelected(allSortBtn.isSelected());
        // select insertion sorting when 'All' is clicked
        insertionSortBtn.setSelected(allSortBtn.isSelected());
        // select quick sorting when 'All' is clicked
        quickSortBtn.setSelected(allSortBtn.isSelected());
    }//GEN-LAST:event_allSortBtnActionPerformed

    private void selectionSortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_selectionSortBtnActionPerformed
        handleSortButtonSelection();
    }//GEN-LAST:event_selectionSortBtnActionPerformed

    private void bubbleSortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bubbleSortBtnActionPerformed
        handleSortButtonSelection();
    }//GEN-LAST:event_bubbleSortBtnActionPerformed

    private void insertionSortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_insertionSortBtnActionPerformed
        handleSortButtonSelection();
    }//GEN-LAST:event_insertionSortBtnActionPerformed

    private void quickSortBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_quickSortBtnActionPerformed
        handleSortButtonSelection();
    }//GEN-LAST:event_quickSortBtnActionPerformed

    private void analyticBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_analyticBtnActionPerformed
        // if no sort was run - show error
        if (sortingTimes.isEmpty()) {
            // show message
            JOptionPane.showMessageDialog(this, "No sorting statistics available. Please perform a sort first.", "No Data", JOptionPane.WARNING_MESSAGE);
            return;
        }

        // int JFreeChart to add sortingTimes
        DefaultCategoryDataset dataset = new DefaultCategoryDataset();
        // interate over        sortingTimes
        for (Map.Entry<String, Long> entry : sortingTimes.entrySet()) {
            // add sorting name and time
            dataset.addValue(entry.getValue(), "Sorting Time (ms)", entry.getKey());
        }

        // create bar chart
        JFreeChart barChart = ChartFactory.createBarChart(
                // title
                "Sorting Algorithm Comparison",
                //categoryAxisLabel
                "Sorting Algorithm",
                // valueAxisLabel
                "Time (ns)",
                // dataset
                dataset,
                // orientation
                PlotOrientation.VERTICAL,
                // legend
                true,
                // tooltips
                true,
                // urls
                false
        );

        // Set the color of the bars to blue
        CategoryPlot plot = barChart.getCategoryPlot();
        BarRenderer renderer = (BarRenderer) plot.getRenderer();
        // // Set the color of the first series to blue
        renderer.setSeriesPaint(0, Color.BLUE);

        // create chart panel
        ChartPanel chartPanel = new ChartPanel(barChart);
        // set its size
        chartPanel.setPreferredSize(new java.awt.Dimension(800, 600));

        // open dialog
        JDialog dialog = new JDialog(this, "Sorting Statistics", true);
        // add chartPanel 
        dialog.setContentPane(chartPanel);
        // fit panel
        dialog.pack();
        // set relative to parent
        dialog.setLocationRelativeTo(this);
        // make visible
        dialog.setVisible(true);
    }//GEN-LAST:event_analyticBtnActionPerformed

    private void randomBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_randomBtnActionPerformed
        // Create random generator
        Random random = new Random();

        // set false to selectionSortBtn
        selectionSortBtn.setSelected(false);
        // set false to bubbleSortBtn
        bubbleSortBtn.setSelected(false);
        // set false to insertionSortBtn
        insertionSortBtn.setSelected(false);
        // set false to quickSortBtn
        quickSortBtn.setSelected(false);
        // set false to allSortBtn
        allSortBtn.setSelected(false);

        // StringBuilder for input with random
        StringBuilder randomNumbers = new StringBuilder();
        // create 20 random
        for (int i = 0; i < 20; i++) {
            // create number up to 100
            int randomInt = random.nextInt(100);
            // append with  "\n"
            randomNumbers.append(randomInt).append("\n");
        }
        // add string to "input" inputTextArea
        inputTextArea.setText(randomNumbers.toString());

        // create algorithm names
        String[] algorithms = {"Bubble Sort", "Insertion Sort", "Quick Sort", "Selection Sort"};
        // random selected algorithms
        int numberOfAlgorithms = random.nextInt(algorithms.length) + 1;

        // create array of selectedAlgorithms
        List<String> selectedAlgorithms = new ArrayList<>();

        // till numberOfAlgorithms
        while (selectedAlgorithms.size() < numberOfAlgorithms) {
            // init random algorithms 
            String randomAlgorithm = algorithms[random.nextInt(algorithms.length)];
            // if selectedAlgorithms does not have yet randomAlgorithm
            if (!selectedAlgorithms.contains(randomAlgorithm)) {
                // add randomAlgorithm 
                selectedAlgorithms.add(randomAlgorithm);
            }
        }

        // iterate over selectedAlgorithms
        for (String algorithm : selectedAlgorithms) {
            switch (algorithm) {
                case "Bubble Sort":
                    // if bubble - > select bubbleSortBtn
                    bubbleSortBtn.setSelected(true);
                    break;
                case "Insertion Sort":
                    // if Insertion - > select insertionSortBtn
                    insertionSortBtn.setSelected(true);
                    break;
                case "Quick Sort":
                    // if Quick - > select quickSortBtn
                    quickSortBtn.setSelected(true);
                    break;
                case "Selection Sort":
                    // if Selection - > select selectionSortBtn
                    selectionSortBtn.setSelected(true);
                    break;
            }
        }

        // if all selected
        if (selectedAlgorithms.size() == algorithms.length) {
            // all is selected
            allSortBtn.setSelected(true);
        }

        // oder list
        String[] orders = {"Ascending", "Descending"};
        // generate random oder
        String randomOrder = orders[random.nextInt(orders.length)];
        // set oder dropdown
        acdOrDecDropdown.setSelectedItem(randomOrder);
    }//GEN-LAST:event_randomBtnActionPerformed

    private void resetBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetBtnActionPerformed
        // reset times
        sortingTimes.clear();
        // reset input list
        inputTextArea.setText("");
        // reset output list
        outputTextArea.setText("");
        //reset selection btn
        selectionSortBtn.setSelected(false);
        //reset bubble btn
        bubbleSortBtn.setSelected(false);
        //reset insertion btn
        insertionSortBtn.setSelected(false);
        //reset quick btn
        quickSortBtn.setSelected(false);
        //reset all btn
        allSortBtn.setSelected(false);
        // set asecding to 'Select'
        acdOrDecDropdown.setSelectedItem("Select");
    }//GEN-LAST:event_resetBtnActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SortingRoutines.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SortingRoutines().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> acdOrDecDropdown;
    private javax.swing.JRadioButton allSortBtn;
    private javax.swing.JButton analyticBtn;
    private javax.swing.JRadioButton bubbleSortBtn;
    private javax.swing.JTextArea inputTextArea;
    private javax.swing.JRadioButton insertionSortBtn;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea outputTextArea;
    private javax.swing.JRadioButton quickSortBtn;
    private javax.swing.JButton randomBtn;
    private javax.swing.JButton resetBtn;
    private javax.swing.JRadioButton selectionSortBtn;
    private javax.swing.JButton sortBtn;
    // End of variables declaration//GEN-END:variables
}
